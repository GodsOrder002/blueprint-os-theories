对，这里要把“**真理源（Git）**”和“**业务数据面（Data Plane）**”拆开：Git 继续当 **控制面/治理内核**，但大体量数据走专门的数据系统；Git 里只放**可审计、可复现所需的最小引用**。

下面给你一套在你现有蓝图体系里“自然延伸”的分层方式（不引入新哲学，直接把 02/04/09/10/13/18/19 落到数据层）。

---

## 1）三层存放：Repo 只存“控制面”

### A. Git Repo（Control Plane / Truth & Governance）

放这些就够了：

* 协议 / 蓝图 / 门禁规则（03/04/10）
* 工位输出的**小工件**（spec、plan、judge report、lint report）
* **证据索引**与引用（09）：只放 `evidence_id` + 元数据 + 指针（URI/哈希/时间/权限域）
* registry（13）：`service_id/gpt_id/version/status/scope/allowed_callers`
* release/tag（04）：稳定版本锚点

**原则：Repo 里永远不放大对象本体**，只放“能复现/能追责”的引用与摘要。

### B. 对象存储（Data Plane / Blob Store）

大文件：原始资料、PDF、长文本、网页抓取快照、数据集切片、embedding 文件等
选型通常是 S3/MinIO/OSS/Blob Storage 这类。

### C. 数据库/仓库（Query Plane）

结构化业务数据、方案产出记录、用户/账户/交易流水、指标、审计日志索引等
Postgres / ClickHouse / Elasticsearch / Lakehouse 都可以，看你吞吐与查询类型。

---

## 2）“证据链”怎么不进 Git 还能可审计？

把 **Evidence 工件**拆成“两件事”：

* **Evidence 实体**（大）：放对象存储/数据仓库
* **Evidence 记录**（小）：放 Git（或 DB 但要可追溯）

Evidence 记录最小字段（你可以当 09 的落地格式）：

* `evidence_id`
* `sha256`（或内容哈希）
* `uri`（对象存储路径）
* `source_type`（pdf/web/db/export…）
* `captured_at`
* `access_scope`（权限域）
* `summary`（短摘要，可选）
* `retrieval_recipe`（如何再取回/再生成，可选）

这样：

* Git 负责“这份证据当时是什么 + 指向哪里 + 版本锚点”
* 数据系统负责“证据本体多大、多快、怎么查”

---

## 3）业务量上来后的“版本语义”怎么保持？

关键是：**版本化的不是数据本体，而是“数据快照引用”**。

你可以在每次方案发布（19）或 stable gate（10）时，生成一个 `DataSnapshot` 工件（小，进 Git）：

* `snapshot_id`
* `dataset_refs[]`（每个包含 uri + hash + range/partition）
* `schema_version`
* `query_seed`（若是通过查询生成）
* `time_window`
* `policy`（权限与脱敏等级）

这就让你的 04（SemVer）和 18（不可变推理服务）在“数据层”也成立：
同一个 release tag 永远指向同一组快照引用，能复跑、能审计、能回滚。

---

## 4）你担心的核心矛盾：吞吐 vs 审计

解决方式是一句话：
**高吞吐走 DB/对象存储；强审计走“哈希 + 快照引用 + gate report 进 Git”。**

运行时（高频）不碰 Git；发布时（低频）把“决定性信息”写入 Git。

---

## 5）一条可执行的落地规则（最简单版本）

> Git 里只允许出现：**可读的协议/规则/小工件 + 指向数据的不可变引用**。
> 任何超过阈值（比如 1–5MB）的内容，一律对象存储，并在 Git 里写入：`id + hash + uri + scope`。

---

如果你愿意，我可以把这件事直接写成你体系里的一个“蓝图补丁”形式（例如给 02/09/10/19 各加一段 **Data Plane 分离规范**），让它能直接进你的蓝图母表和门禁规则里。
