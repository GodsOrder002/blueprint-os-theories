你的这个经验背后是个很常见的取舍：**把 DB 当 KV/记录仓库，用业务层做“拼接/聚合”**。它在一些场景确实更稳、更容易扩展，但“高并发下两次查询一定比 join 更快”这个结论并不总成立——更准确的说法是：**当 join 会放大扫描/排序/临时表、或者会让热点锁更重时，拆成两次 + 缓存/批量查询，往往更可控**。

我按你说的“主子约束”这个例子，把判断框架讲清楚（不讲落地细节）：

---

## 什么时候“两次查 + 业务层拼接”更划算

1. **读路径超热点，且结果可缓存**

   * 典型：配置、规则、约束这种“写少读多”的数据
   * 做法：第一次查边（master→child ids），第二次批量查子节点详情；两次都能被缓存命中。

2. **join 会导致大范围扫描或临时表**

   * join 的一侧选择性差（比如 status 很宽、过滤不强）
   * 或者 join 后还要 `ORDER BY`/`GROUP BY`，容易上临时表、filesort。

3. **你需要更好的降级策略**

   * 两次查：第二次失败还能返回“只有关系没详情/只返回主约束”等可控降级
   * join：要么全有要么全无。

4. **跨库 / 分库分表 / 读写分离**

   * join 天然受限，而“多次查询+业务层聚合”更容易适配架构演进。

---

## 什么时候 join 反而更划算（甚至更快）

1. **一次网络往返 vs 两次往返**

   * 两次查询是两次网络 RTT + 两次解析执行 + 两次结果传输
   * 如果你在同城低延迟还好，但在高延迟链路上，RTT 很容易变成瓶颈。

2. **join 的过滤很强、索引命中好，行数小**

   * 这种 join 通常就是“索引嵌套循环”，MySQL 做得很快
   * 你拆成两次反而多一次往返，收益不大。

3. **一致性要求强**

   * 两次查询如果不包在同一个事务/同一个一致性快照里，可能读到不一致（边表更新了、明细表没更新或相反）
   * join 在同一条语句里天然一致。

---

## 你这类“约束/规则库”我会怎么建议

**倾向你那套思路**：把它当“配置/规则”而不是 OLTP 核心交易表。

* 读多写少：非常适合**两次查 + 缓存**
* 关系边表（master→child）和节点表（约束详情）天然就是“图/树结构”：业务层做展开也自然
* 如果未来要做递归（整棵树），业务层展开往往比 SQL 递归更可控（尤其你要做版本、灰度、降级）

但我会补一句关键点：
**两次查要避免 N+1** ——不要 child 一个个查，而是“先拿 ids，再 `IN (...)` 一次批量查”。

---

## 给你一个可执行的判断准则（很实用）

* **P99 延迟主要在网络/应用** → 能 join 就 join（减少 RTT）
* **P99 延迟主要在 DB（扫描/锁/临时表）** → 倾向拆查询 + 缓存 + 批量
* **读多写少的规则/配置** → 拆 + 缓存 通常赢
* **强一致性交易** → join/事务一致性更重要

---

如果你愿意，我可以直接按你的“尽量只读写、业务层拼接”的风格，把“主子约束”这一套表结构再调整成更符合这个理念的（例如：减少外键/触发器依赖、把校验放业务层、以及更适合缓存的字段设计）。你更偏向：**完全不启用外键** 还是 **保留外键但不用复杂约束**？
